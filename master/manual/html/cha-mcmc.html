<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>BAT manual: Markov chain Monte Carlo</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    TeX: {
        Macros: {
            cond: ["{\\,|\\,}"],
            diag: ["{\\mbox{diag}}"],
            matsig: ["{\\boldsymbol{\\Sigma}}"],
            rmdx: ["{\\mbox{d}#1\\,}",1],
            scath: ["{\\theta}"],
            vecmu: ["{\\boldsymbol{\\mu}}"],
            vecth: ["{\\boldsymbol{\\theta}}"],
            order: ["{\\mathcal{O}(#1)}",1],
        }
    }
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">BAT manual 1.0.0</a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Overview</span></a></li>
      <li class="current"><a href="pages.html"><span>Chapters</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Markov chain Monte Carlo </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec-mcmc-motiv">Motivation</a></li>
<li class="level1"><a href="#sec-mcmc-foundations">Foundations</a><ul><li class="level2"><a href="#sec-mcmc-integration">Monte Carlo integration</a></li>
<li class="level2"><a href="#sec-mcmc-metropolis">Metropolis algorithm</a></li>
<li class="level2"><a href="#sec-mcmc-convergence">Convergence</a></li>
</ul>
</li>
<li class="level1"><a href="#sec-mcmc-impl">Implementation in BAT</a><ul><li class="level2"><a href="#sec-mcmc-proposal">Proposal functions</a><ul><li class="level3"><a href="#sec-mcmc-multivariate">Multivariate proposal</a></li>
<li class="level3"><a href="#sec-mcmc-factorized">Factorized proposal</a></li>
<li class="level3"><a href="#sec-mcmc-proposal-comparison">Comparison</a></li>
</ul>
</li>
<li class="level2"><a href="#sec-mcmc-prerun">Prerun</a><ul><li class="level3"><a href="#sec-mcmc-eff">Efficiency</a></li>
<li class="level3"><a href="#sec-mcmc-Rvalue">R value</a></li>
<li class="level3"><a href="#sec-mcmc-prerun-length">Prerun length</a></li>
</ul>
</li>
<li class="level2"><a href="#sec-mcmc-main-run">Main run</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="sec-mcmc-motiv"></a>
Motivation</h1>
<p>Among the integration methods introduced in <a class="el" href="cha-integration.html">Integration</a>, the Monte Carlo method is the most powerful one in high dimensions. The term Monte Carlo is used as a synonym for the use of pseudo-random numbers. Markov chains are a particular class of Monte Carlo algorithms designed to generate correlated samples from an arbitrary distribution. The central workhorse in BAT is an adaptive Markov chain Monte Carlo (MCMC) implementation based on the Metropolis algorithm. It allows users to marginalize a posterior without requiring manual tuning of algorithm parameters. In complicated cases, tweaking the parameters can substantially increase the efficiency, so BAT gives users full access to all tuning parameters.</p>
<h1><a class="anchor" id="sec-mcmc-foundations"></a>
Foundations</h1>
<h2><a class="anchor" id="sec-mcmc-integration"></a>
Monte Carlo integration</h2>
<p>We begin with the <em>fundamental Monte Carlo</em> principle. Suppose we have a posterior probability density \(P(\vecth|D)\), often called the <em>target</em> density, and an arbitrary function \(f(\vecth)\) with finite expectation value under \(P\) </p><p class="formulaDsp">
\begin{align} \label{eq:mc-expect} E_P[ f ] = \int \rmdx{ \vecth} P(\vecth|D) f(\vecth) &lt; \infty . \end{align}
</p>
<p> Then a set of draws \(\{ \vecth_i:i=1 \dots N \}\) from the density \(P\), that is \(\vecth_i \sim P\), is enough to estimate the expectation value. Specifically, the integral can be replaced by the estimator (distinguished by the symbol \(\widehat{\phantom{a}}\)) </p><p class="formulaDsp">
\begin{align} \label{eq:mc-expect-discrete} \boxed{ \widehat{E_P[f]} \approx \frac{1}{N} \sum_{i=1}^{N} f(\vecth_i), \; \vecth \sim P } \end{align}
</p>
<p> As \(N \to \infty\), the estimate converges almost surely at a rate \(\propto 1/\sqrt{N}\) by the strong law of large numbers if \(\int \rmdx{ \vecth} P(\vecth|D) f^2(\vecth) &lt; \infty\) <a class="el" href="citelist.html#CITEREF_Casella:2004">[11]</a> . This is true for independent samples from the target but also for correlated samples. The only thing that changes is the increased variance of the estimator due to correlation.</p>
<p><a class="anchor" id="mcmc-histogram"></a> <style>div.image img[src="histogram.svg"]{width:300px;}</style> </p><div class="image">
<img src="histogram.svg" alt="histogram.svg"/>
<div class="caption">
Histogram approximation to the 1D marginal.</div></div>
<p>How does this relate to Bayesian inference? Upon applying Bayes’ theorem to real-life problems, one usually has to marginalize over several parameters, and this can usually not be done analytically, hence one has to resort to numerical techniques. In low dimensions, say \(d \le 2\), quadrature and other grid-based methods are fast and accurate, but as \(d\) increases, these methods generically suffer from the <em>curse of dimensionality</em>. The number of function evaluations grows exponentially as \(\order{m^d}\), where \(m\) is the number of grid points in one dimension. Though less accurate in few dimensions, Monte Carlo — i.e., random-number based — methods are the first choice in \(d \gtrsim 3\) because the computational complexity is (at least in principle) independent of \(d\). Which function \(f\) is of interest to us? For example when integrating over all but the first dimension of \(\vecth\), the marginal posterior probability that \(\theta_1\) is in \([a,b)\) can be estimated as</p>
<p class="formulaDsp">
\[ \label{eq:disc-marg} P(a \le \theta_1 \le b|D) \approx \frac{1}{N} \sum_{i=1}^{N} \mathbf{1}_{\theta_1 \in [a,b)} (\vecth_i) \, \]
</p>
<p> with the <em>indicator function</em> </p><p class="formulaDsp">
\[ \label{eq:indicator-fct} \mathbf{1}_{\theta_1 \in [a,b)} (\vecth) = \begin{cases} 1, \theta_1 \in [a,b) \\ 0, {\rm else} \end{cases} \]
</p>
<p>This follows immediately from the Monte Carlo principle with \(f(\vecth) = \mathbf{1}_{\theta_1 \in [a,b)}(\vecth)\). The major simplification arises as we perform the integral over \(d-1\) dimensions simply by ignoring these dimensions in the indicator function. If the parameter range of \(\theta_1\) is partitioned into bins, then the above holds in every bin, and defines the histogram approximation to \(P(\theta_1|D)\). In exact analogy, the 2D histogram approximation is computed from the samples for 2D bins in the indicator function. For understanding and presenting the results of Bayesian parameter inference, the set of 1D and 2D marginal distributions is the primary goal. Given samples from the full posterior, we have immediate access to <em>all</em> marginal distributions at once; i.e., there is no need for separate integration to obtain for example \(P(\theta_1|D)\) and \(P(\theta_2|D)\). This is a major benefit of the Monte Carlo method in conducting Bayesian inference.</p>
<h2><a class="anchor" id="sec-mcmc-metropolis"></a>
Metropolis algorithm</h2>
<p>The key ingredient in BAT is an implementation of the Metropolis algorithm to create a Markov chain; i.e. a sequence of (correlated) samples from the posterior. We use the shorthand MCMC for Markov chain Monte Carlo.</p>
<p>Efficient MCMC algorithms are the topic of past and current research. This section is a concise overview of the general idea and the algorithms available in BAT. For a broader overview, we refer the reader to the abundant literature; e.g., <a class="el" href="citelist.html#CITEREF_Casella:2004">[11]</a> <a class="el" href="citelist.html#CITEREF_brooks2011handbook">[2]</a> .</p>
<p>In BAT, there are several variants of the random-walk Metropolis Hastings algorithm available. The basic idea is captured in the <a class="el" href="cha-mcmc.html#random-walk-2D">2D example plot</a>. Given an initial point \(\vecth_0\), the Metropolis algorithm produces a sample in each iteration \(t=1 \dots N \) as follows:</p>
<ul>
<li>Propose a new point \(\tilde{\vecth}\)</li>
<li>Generate a number u from the uniform distribution on [0,1]</li>
<li>Set \(\vecth_{t} = \tilde{\vecth}\) if \( u &lt; \frac{P(\tilde{\vecth} \cond D)}{P(\vecth_{t-1} \cond D)}\)</li>
<li>Else stay, \(\vecth_t = \vecth_{t-1}\)</li>
</ul>
<p><a class="anchor" id="random-walk-2D"></a></p><div class="image">
<img src="random-walk.png" alt="random-walk.png"/>
<div class="caption">
2D random walk with the Metropolis algorithm.</div></div>
<p>In the example plot, the chain begins in the lower left corner. Rejected moves are indicated by the dashed arrow, accepted moves are indicated by the solid arrow. The circled number is the number of iterations the chain stays at a given point \(\vecth = (\theta_1, \theta_2)\).</p>
<p>In each iteration \(t\), one updates the estimate of the 1D marginal distribution \(P(\theta_1 | D)\) by adding the first coordinate of \(\vecth_t\) to a histogram. Repeat this for all other coordinates to update the other \((d-1)\) 1D marginals. And redo it for all pairs of coordinates to estimate the 2D marginals.</p>
<p>As a concrete example, suppose the chain has 5 iterations in 2D:</p>
<table class="doxtable">
<tr>
<th align="left">\(t\) </th><th align="left">\(\vecth_t\)  </th></tr>
<tr>
<td align="left">1 </td><td align="left">\((1.1, 2.3)\) </td></tr>
<tr>
<td align="left">2 </td><td align="left">\((1.1, 2.3)\) </td></tr>
<tr>
<td align="left">3 </td><td align="left">\((3.8, 1.8)\) </td></tr>
<tr>
<td align="left">4 </td><td align="left">\((2.4, 5.2)\) </td></tr>
<tr>
<td align="left">5 </td><td align="left">\((1.8, 4.2)\) </td></tr>
</table>
<p>Let us choose a histogram to approximate the 1D marginal posterior for \(\theta_1\) with five bins from \([n, n+1)\) for \(n=0 \dots 4\) such that the right edge of the bin is not included. Up to \(t=5\), the histogram is</p>
<table class="doxtable">
<tr>
<th align="left">\(n\)</th><th align="left">weight  </th></tr>
<tr>
<td align="left">0 </td><td align="left">0 </td></tr>
<tr>
<td align="left">1 </td><td align="left">3 </td></tr>
<tr>
<td align="left">2 </td><td align="left">1 </td></tr>
<tr>
<td align="left">3 </td><td align="left">1 </td></tr>
<tr>
<td align="left">4 </td><td align="left">0 </td></tr>
</table>
<p>In the end, we usually normalize the histogram so it estimates a proper probability density that integrates to 1.</p>
<h2><a class="anchor" id="sec-mcmc-convergence"></a>
Convergence</h2>
<p>Since samples are not independent, the initial point has some effect on Markov chain output. The asymptotic results guarantee that, under certain conditions (see <a class="el" href="citelist.html#CITEREF_Casella:2004">[11]</a> or <a class="el" href="citelist.html#CITEREF_brooks2011handbook">[2]</a>) a chain of infinite length is independent of the initial point. In practice, we can only generate a finite number of points so a decision has to be made when the chain has run long enough. One helpful criterion is to run multiple chains from different initial positions and to declare convergence if the chains mixed; i.e. explore the same region of parameter space. Then the chains have forgotten their initial point.</p>
<p>Non-convergence is a problem that can have many causes including simple bugs in implementing the posterior. But there are properly implemented posteriors for which a Markov chain has difficulties to explore the parameter space efficiently, for example because of strong correlation, degeneracies, or multiple well separated modes.</p>
<h1><a class="anchor" id="sec-mcmc-impl"></a>
Implementation in BAT</h1>
<p>Implementing the Metropolis algorithm, one has to decide on how to propose a new point based on the current point, that is one needs the <em>proposal function</em> \(q(\tilde{\vecth} \cond \vecth_t, \xi)\) with adjustable parameters \(\xi\). The main difference between MCMC algorithms is typically given by different choices of \(q\). The Metropolis algorithm doesn't specify which \(q\) to choose, so we can and have to select a function \(q\) and tune \(\xi\) according to our needs.</p>
<p>In BAT, the proposal is <em>symmetric</em> around the current point </p><p class="formulaDsp">
\begin{align} q(\tilde{\vecth} \cond \vecth_t, \xi) = q(\vecth_t \cond \tilde{\vecth}, \xi). \end{align}
</p>
<p>The Markov property implies that the proposal may only depend on the current point \(\vecth_t\) and not on any previous point. If the value of \(\xi\) is set based on a past sequence of iterations of the chain, we need two stages of sampling in BAT, the <em>prerun</em> and the <em>main run</em>. In the prerun, the chain is run and periodically \(\xi\) is updated based on the past iterations. In contrast, \(\xi\) is kept fixed in the main run to have a proper Markov chain.</p>
<h2><a class="anchor" id="sec-mcmc-proposal"></a>
Proposal functions</h2>
<p>BAT offers two kinds of proposal function termed <em>factorized</em> and <em>multivariate</em>. The general form is either a Gaussian or Student's t distribution. In the factorized case, the joint distribution is a product of 1D distributions. In the multivariate case, a dense covariance matrix is used that allows correlated proposals. In either case, the default is Student's t distribution with one degree of freedom (dof); i.e., a Cauchy distribution. Select the proposal like this:</p>
<div class="fragment"><div class="line">m.SetProposeMultivariate(<span class="keyword">true</span>);</div><div class="line">m.SetProposalFunctionDof(5); <span class="comment">// Student&#39;s t with 5 degrees of freedom</span></div><div class="line">m.SetProposalFunctionDof(-1); <span class="comment">// Gaussian</span></div></div><!-- fragment --><h3><a class="anchor" id="sec-mcmc-multivariate"></a>
Multivariate proposal</h3>
<dl class="section since"><dt>Since</dt><dd>Introduced and set as the default in v1.0</dd></dl>
<p>Changing all \(d\) parameters at once within one iteration is an all-or-nothing approach. If the proposed move is accepted, all parameters have changed for the price of a single evaluation of the posterior. If the move is rejected, the new point is identical to the old point and the chain does not explore the parameter space.</p>
<p>We implement the adaptive algorithm by Haario et al. <a class="el" href="citelist.html#CITEREF_Haario:2001">[6]</a>, <a class="el" href="citelist.html#CITEREF_Wraith:2009if">[15]</a>. In brief, the proposal is a multivariate Gaussian or Student's t distribution whose covariance is learned from the covariance of samples in the prerun. An overall scale factor is tuned to force the acceptance rate into a certain range.</p>
<p>the multivariate normal distribution </p><p class="formulaDsp">
\begin{equation} \label{eq:multivar-normal} \mathcal{N}(\vecth | \vecmu, \matsig) = \frac{1}{(2\pi)^{d/2}} \left|\matsig\right|^{-1/2} \exp(-\frac{1}{2} (\vecth - \vecmu)^T \matsig^{-1} (\vecth - \vecmu) ) \end{equation}
</p>
<p>or the multivariate Student's t distribution </p><p class="formulaDsp">
\begin{equation} \label{eq:multivar-student} \mathcal{T} (\vecth | \vecmu, \matsig, \nu) = \frac{\Gamma( (\nu + d) / 2 )}{\Gamma(\nu / 2) (\pi \nu)^{d/2}} \left|\matsig\right|^{-1/2} ( 1 + \frac{1}{\nu}(\vecth - \vecmu)^T \matsig^{-1} (\vecth - \vecmu) )^{-(\nu + d)/2} \end{equation}
</p>
<p> can adapt in such a way as to efficiently generate samples from essentially any smooth, unimodal distribution. The parameter \(\nu\), the degree of freedom, controls the ``fatness'' of the tails of \(\mathcal{T}\); the covariance of \(\mathcal{T}\) is related to the scale matrix \(\matsig\) as \(\frac{\nu}{\nu - 2} \times \matsig\) for \(\nu &gt; 2\), while \(\matsig\) is the covariance of \(\mathcal{N}\). Hence for finite \(\nu\), \(\mathcal{T}\) has fatter tails than \(\mathcal{N}\), and for \(\nu \to \infty\), \(\mathcal{T}(\vecth | \vecmu, \matsig, \nu) \to \mathcal{N}(\vecth | \vecmu, \matsig)\).</p>
<p>Before delving into the details, let us clarify at least qualitatively what we mean by an efficient proposal. Our requirements are</p>
<ul>
<li>that it allow to sample from the entire target support in finite time,</li>
<li>that it resolve small and large scale features of the target,</li>
<li>and that it lead to a Markov chain quickly reaching the asymptotic regime.</li>
</ul>
<p>An important characteristic of Markov chains is the acceptance rate \(\alpha\), the ratio of accepted proposal points versus the total length of the chain. We argue that there exists an optimal \(\alpha\) for a given target and proposal. If \(\alpha = 0\), the chain is stuck and does not explore the state space at all. On the contrary, suppose \(\alpha = 1\) and the target distribution is not globally uniform, then the chain explores only a tiny volume where the target distribution changes very little. So for some \(\alpha \in (0,1)\), the chains explore the state space well.</p>
<p>How should the proposal function be adapted? After a chunk of \(N_{\rm update}\) iterations, we change two things. First, in order to propose points according to the correlation present in the target density, the proposal scale matrix \(\matsig\) is updated based on the sample covariance of the last \(n\) iterations. Second, \(\matsig\) is multiplied with a scale factor \(c\) that governs the range of the proposal. \(c\) is tuned to force the acceptance rate to lie in a region of \(0.15 \le \alpha \le 0.35\). The \(\alpha\) range is based on empirical evidence and the following fact: for a multivariate normal proposal function, the optimal \(\alpha\) for a normal target density is \(0.234\), and the optimal scale factor is \(c = 2.38^2/d\) as the dimensionality \(d\) approaches \(\infty\) and the chain is in the stationary regime <a class="el" href="citelist.html#CITEREF_Roberts:1997">[12]</a> . We fix the proposal after a certain number of adaptations, and then collect samples for the final inference step. However, if the Gaussian proposal function is adapted indefinitely, the Markov property is lost, but the chain and the empirical averages of the integrals still converge under mild conditions <a class="el" href="citelist.html#CITEREF_Haario:2001">[6]</a>.</p>
<p>The efficiency can be enhanced significantly with good initial guesses for \(c\) and \(\matsig\). We use a subscript \(t\) to denote the status after \(t\) updates. It is often possible to extract an estimate of the target covariance by running a mode finder like MINUIT that yields the covariance matrix at the mode as a by product of optimization. In the case of a degenerate target density, MINUIT necessarily fails, as the gradient is not defined. In such cases, one can still provide an estimate as </p><p class="formulaDsp">
\begin{equation} \label{eq:sigma-initial} \matsig^0 = \diag ( \sigma_1^2, \sigma_2^2, \dots, \sigma_d^2) \end{equation}
</p>
<p> where \(\sigma_i^2\) is the prior variance of the \(i\)-th parameter. The updated value of \(\matsig\) in step \(t\) is </p><p class="formulaDsp">
\begin{equation} \label{eq:sigma-update} \matsig^t = (1 - a^t) \matsig^{t-1} + a^t \boldsymbol{S}^t \end{equation}
</p>
<p> where \(\boldsymbol{S}^t\) is the sample covariance of the points in chunk \(t\) and its element in row \(m\) and column \(n\) is computed as </p><p class="formulaDsp">
\begin{equation} \label{eq:sample-cov} (\boldsymbol{S}^t)_{mn} = \frac{1}{N_{\rm update}-1} \sum_{i=(t-1) \cdot N_{\rm update}}^{t \cdot N_{\rm update}} ( (\vecth^i)_m - \widehat{E_P[(\vecth)_m]} ) ((\vecth^i)_n - \widehat{E_P[(\vecth)_n]} ) \end{equation}
</p>
<p> The weight \(a^t = 1/t^{\lambda}, \lambda \in [0,1]\) is chosen to make for a smooth transition from the initial guess to the eventual target covariance, the implied cooling is needed for the ergodicity of the chain if the proposal is not fixed at some point <a class="el" href="citelist.html#CITEREF_Haario:2001">[6]</a>. One uses a fixed value of \(\lambda\), and the particular value has an effect on the efficiency, but the effect is generally not dramatic; in this work, we set \(\lambda=0.5\) <a class="el" href="citelist.html#CITEREF_Wraith:2009if">[15]</a>.</p>
<p>We adjust the scale factor \(c\) as described in the pseudocode shown below. The introduction of a minimum and maximum scale factor is a safeguard against bugs in the implementation. The only example we can think of that would result in large scale factors is that of sampling from a uniform distribution over a very large volume. All proposed points would be in the volume, and accepted, so \(\alpha \equiv 1\), irrespective of \(c\). All other cases that we encountered where \(c &gt; c_{max}\) hinted at errors in the code that performs the update of the proposal.</p>
<div class="fragment"><div class="line"><span class="comment">// default values</span></div><div class="line">αmin = 0.15; αmax = 0.35;</div><div class="line">cmin = 1e-5; cmax = 100;</div><div class="line">β = 1.5;</div><div class="line"></div><div class="line"><span class="comment">// single update of the covariance scale factor</span></div><div class="line"><span class="keywordflow">if</span> (α &gt; αmax &amp;&amp; c &lt; cmax) {</div><div class="line">  c *= β * c</div><div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (α &lt; αmin &amp;&amp; c &gt; cmin) {</div><div class="line">  c /= β</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#ab8740355c3d18a9ee8744207441b0874">BCEngineMCMC::SetMultivariateCovarianceUpdateLambda</a></code>, <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#ab0f219debd18a6a70c81988aeb3b6d71">BCEngineMCMC::SetMultivariateEpsilon</a></code>, <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a19546b734b8cab453951b1d420b1b5dd">BCEngineMCMC::SetMultivariateScaleMultiplier</a></code></dd></dl>
<h3><a class="anchor" id="sec-mcmc-factorized"></a>
Factorized proposal</h3>
<dl class="section since"><dt>Since</dt><dd>Factorized was the default and only choice prior to v1.0 and continues to be available using <code>BCEngineMCMC::SetProposeMultivariate(false)</code></dd></dl>
<p>The factorized proposal in \(d\) dimensions is a product of 1D proposals.</p>
<p>We sequentially vary one parameter at a time and complete one iteration of the chain once a new point has been proposed in <em>every</em> direction. This means the chain attempts to perform a sequence of axis-aligned moves in one iteration.</p>
<p>Each 1D proposal is a Cauchy or Breit-Wigner function centered on the current point. The scale parameter is adapted in the prerun to achieve an acceptance rate in a given range that can be adjusted by the user. Note that there is a separate scale parameter in every dimension.</p>
<p>This means the posterior is called \(d\) times in every iteration. Since the acceptance rate is typically different from zero or one, the factorized proposal typically generates a new point in every iteration that differs from the previous point in some but not all dimensions.</p>
<h3><a class="anchor" id="sec-mcmc-proposal-comparison"></a>
Comparison</h3>
<p>Comparing the factorized proposal to the multivariate proposal, we generally recommend the multivariate for most purposes.</p>
<p>Use the factorized proposal if you can speed up the computation of the posterior if you know that some parameters did not change. This can be useful if the computation is expensive if some but not all parameters change.</p>
<h2><a class="anchor" id="sec-mcmc-prerun"></a>
Prerun</h2>
<p>During the prerun, the proposal is updated. BAT considers three criteria to decide when to end the prerun. The prerun takes some minimum number of iterations and is stopped no matter what if the maximum number of prerun iterations is reached. In between, the prerun terminates if the efficiency and the \(R\) value checks are ok. To perform the prerun manually, do</p>
<div class="fragment"><div class="line">m.MetropolisPreRun();</div></div><!-- fragment --><p>In most cases this is not needed, because <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCIntegrate.html#ac84ea45bae755f89e719a08ffa4db57f">BCModel::MarginalizeAll</a></code> calls <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#ae2e36c793ab105ede482a1d421ec1c60">BCEngineMCMC::Metropolis</a></code>, which will take care of the prerun and the main run and all the data handling associated with it. To force a prerun to be run again, perhaps after it failed and some settings have been adjusted, do:</p>
<div class="fragment"><div class="line">m.SetFlagPreRun(<span class="keyword">true</span>);</div><div class="line">m.MarginalizeAll();</div></div><!-- fragment --><h3><a class="anchor" id="sec-mcmc-eff"></a>
Efficiency</h3>
<p>The <em>efficiency</em>, or acceptance rate, is the ratio of the accepted over the total number proposal moves. A small efficiency means the chain rarely moves but may then make a large move. A large efficiency means the chain explores well locally but may take a long time to explore the entire region of high probability. Optimality results exists only for very special cases: Roberts and Rosenthal showed that for a Gaussian target with \(d\) independent components and a Gaussian proposal, the optimal target efficiency is 23.4 % for \(d \geq 5\) is but should be larger for small \(d\); e.g., 44 % is best in one dimension <a class="el" href="citelist.html#CITEREF_rosenthal2011optimal">[13]</a> . Based on our experience, we use a default range for the efficiency as \([0.15, 0.35]\).</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a4bb0f931005f762876bfb163ade4afc7">BCEngineMCMC::SetMinimumEfficiency</a></code>, <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a70bf3ff35665dd856efbcfbd40f84c3d">BCEngineMCMC::SetMaximumEfficiency</a></code></dd></dl>
<h3><a class="anchor" id="sec-mcmc-Rvalue"></a>
R value</h3>
<p>The <em>R value</em> <a class="el" href="citelist.html#CITEREF_Gelman:1992">[4]</a> by Gelman and Rubin quantifies the estimated scale reduction of the uncertainty of an expectation value estimated with the samples if the chain were run infinitely long. Informally, it compares the mean and variance of the expectation value for a single chain with the corresponding results of multiple chains. If the chains mix despite different initial values, then we assume that they are independent of the initial value, the burn-in is over, and the samples produce reliable estimates of quantities of interest. For a single chain, the \(R\) value cannot be computed.</p>
<p>In BAT, we monitor the expectation value of each parameter and declare convergence if all R values are below a threshold. Note that the R values are estimated from batches of samples, and they usually decrease with more iterations but they may also increase, which usually is a clear indication that the chains do not mix, perhaps due to multiple modes that trap the chains.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a8002cb58c287691c2a69fc18b9b63d07">BCEngineMCMC::SetRValueParametersCriterion</a></code> Set the maximum allowed \(R\) value for all parameters. By defition, \(R\) cannot go below 1 except for numerical inaccuracy. <b>Default: 1.1</b></dd>
<dd>
<code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a26274873267b4ea07ff82795480ca53c">BCEngineMCMC::SetCorrectRValueForSamplingVariability</a></code> The strict definition of \(R\) corrects the sampling variability due finite batch size. <b>Default: false</b></dd>
<dd>
<code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#ac12ecd31b01c6b9157d7a34c195a9a51">BCEngineMCMC::GetRValueParameters</a></code> \(R\) values are computed during the prerun and they can be retrieved but not set.</dd></dl>
<h3><a class="anchor" id="sec-mcmc-prerun-length"></a>
Prerun length</h3>
<p>Defining convergence automatically based on the efficiency or the \(R\) value is convenient may be too conservative if the user knows a good initial value, a good proposal, etc. For more control the minimum and maximum length of the prerun can be set, too.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a4be0b2f087a6911c9f4e1ca66b2668bb">BCEngineMCMC::SetNIterationsPreRunMin</a></code>, <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a673f41ff4c667f81acdf7936173e3818">BCEngineMCMC::SetNIterationsPreRunMax</a></code></dd>
<dd>
<code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#abea983c2131efdb640175651948acd55">BCEngineMCMC::SetNIterationsPreRunCheck</a></code> sets the number of iterations between checks</dd></dl>
<p>If desired, the statistics can be cleared to remove the effect of a bad initial point with <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#aee6c53619d87454dd93aac8c61893a4b">BCEngineMCMC::SetPreRunCheckClear</a></code> after some set of iterations</p>
<p>For the user's convenience, multiple settings related to precision of the Markov chain can be set at once using <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#abfe354986716fbc9bb9d1ebbd1b34cd6">BCEngineMCMC::SetPrecision</a></code>. The default setting is <code>m.SetPrecision(BCEngineMCMC::kMedium)</code>.</p>
<h2><a class="anchor" id="sec-mcmc-main-run"></a>
Main run</h2>
<p>In the main run, the proposal is held fixed and each chain is run for <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a894e8a8dfcb63fd30237101460c1c401">BCEngineMCMC::GetNIterationsRun()</a></code> iterations. </p><dl class="section see"><dt>See also</dt><dd><code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a96d7399c4302677a537b062e1d684281">BCEngineMCMC::SetNIterationsRun</a></code></dd></dl>
<p>To reduce the correlation between samples, a lag can be introduced to take only every 10th element with <code><a class="elRef" doxygen="/root/bat/doc/ref-guide/bat-ref.tag:../../ref-guide/html/" href="../../ref-guide/html/classBCEngineMCMC.html#a7a135b8e4a2b25fa084a09dff51620e2">BCEngineMCMC::SetNLag</a></code>. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!-- <hr class="footer"/><address class="footer"><small> -->
<!-- Generated on Fri May 18 2018 12:43:13 for BAT manual by &#160;<a href="http://www.doxygen.org/index.html"> -->
<!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
<!-- </a> 1.8.11 -->
<!-- </small></address> -->
</body>
</html>
